<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="x-ua-compatible" content="ie=edge" />
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, viewport-fit=cover"
    />

    <style>
      :root {
        --accent-color: #05a081;
        --accent-color-light: #82d0c0;
      }
    </style>

    <meta name="theme-color" content="#05a081" />

    
      <link rel="icon" href="[object]" />
      <link rel="apple-touch-icon" sizes="48x48" href="[object]" />
      <link rel="apple-touch-icon" sizes="72x72" href="[object]" />
      <link rel="apple-touch-icon" sizes="96x96" href="[object]" />
      <link rel="apple-touch-icon" sizes="144x144" href="[object]" />
      <link rel="apple-touch-icon" sizes="192x192" href="[object]" />
      <link rel="apple-touch-icon" sizes="256x256" href="[object]" />
      <link rel="apple-touch-icon" sizes="384x384" href="[object]" />
      <link rel="apple-touch-icon" sizes="512x512" href="[object]" />
    

    

    <meta property="og:type" content="website">

    <meta name="twitter:card" content="summary">

    

    

    
      
        <meta name="description" content="" />
        <meta name="twitter:description" content="">
      
    

    
      <meta name="twitter:title" content="Learning to &#x27;try!&#x27; things in Rust">
    

    
      <link rel="prerender" href="&#x2F;" rel="me" />
    
      <link rel="prerender" href="&#x2F;tags" rel="me" />
    
      <link rel="prerender" href="https:&#x2F;&#x2F;bsky.app&#x2F;profile&#x2F;sophiajt.com" rel="me" />
    
      <link rel="prerender" href="https:&#x2F;&#x2F;grrl.me&#x2F;@soph" rel="me" />
    
      <link rel="prerender" href="&#x2F;atom.xml" rel="me" />
    
      <link rel="prerender" href="&#x2F;poems&#x2F;waitingtogrow" rel="me" />
    

    <link rel="prefetch" href="[object]" />

    <title>
      
        
          Learning to &#x27;try!&#x27; things in Rust
        
      
    </title>

    
    
      <link rel="stylesheet" href="https://www.sophiajt.com/main.css">
    
    
  

  

  
    <link rel="prerender"  href="https://www.sophiajt.com/tags/rust/">
  

  <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "NewsArticle",
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://google.com/article"
      },
      "headline": "Learning to &#x27;try!&#x27; things in Rust",
      "image": [],
      "datePublished": "2015-11-04T00:00:00+00:00",
      "dateModified": "2015-11-04T00:00:00+00:00",
      "author": {
        "@type": "Person",
        "name": "Sophia June Turner"
      },
       "publisher": {
        "@type": "Organization",
        "name": "Sophia June Turner",
        "logo": {
          "@type": "ImageObject",
          "url": "https://www.sophiajt.com/icon.jpg"
        }
        
      }
      
    }
  </script>

  <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "BreadcrumbList",
      "itemListElement": [
        

        
        {
          
          "@type": "ListItem",
          "position": 1,
          "name": "",
          "item": "https://www.sophiajt.com/"
        },
        
        {
          "@type": "ListItem",
          "position": 2,
          "name": "Learning to &#x27;try!&#x27; things in Rust",
          "item": "https://www.sophiajt.com/learning-to-try-things-in-rust/"
        }
      ]
    }
  </script>

  </head>
  <body>
    
      <header>
        <a class="profile-icon" href="/">
          <img src="/icon.jpg" alt="profile picture">
        </a>
        <nav>
          
            <a rel="me" href="&#x2F;">Home</a>
          
            <a rel="me" href="&#x2F;tags">Tags</a>
          
            <a rel="me" href="https:&#x2F;&#x2F;bsky.app&#x2F;profile&#x2F;sophiajt.com">Bluesky</a>
          
            <a rel="me" href="https:&#x2F;&#x2F;grrl.me&#x2F;@soph">Mastodon</a>
          
            <a rel="me" href="&#x2F;atom.xml">Atom&#x2F;RSS</a>
          
            <a rel="me" href="&#x2F;poems&#x2F;waitingtogrow">Poems</a>
          
        </nav>
      </header>
    
    <main>
    
  <div class="post-title">
    <h1>Learning to &#x27;try!&#x27; things in Rust</h1>
    <small>
      November 04, 2015
      
        - 
        <span class="tags">
          
            <a href="https://www.sophiajt.com/tags/rust/">rust</a>
          
        </span>
      
    </small>
  </div>

  <div>
    <p>I started learning Rust in earnest a few weeks ago.  Coming from C++, a fair share of the idioms felt right at home.  There was clear memory management and an eye towards lightweight abstractions.</p>
<p>But when I started looking around for how to do exceptions, I was surprised to find that Rust had none.  In its place were types like this:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">foo_maker</span><span>() -&gt; Result&lt;Foo, io::Error&gt; { ...}
</span></code></pre>
<p>I recognized this style, having come from playing with languages like Haskell, but despite doing some functional programming before I wasn't entirely sure how to approach it.  At first blush, the Result value seems pretty straightforward, it either returns something of Foo or an io::Error.  We know which one it returns by pattern matching out the value:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">let</span><span> result = </span><span style="color:#96b5b4;">foo_maker</span><span>();
</span><span style="color:#b48ead;">match</span><span> result {
</span><span>  Ok(foo) -&gt; foo,
</span><span>  Err(err) -&gt; println!(&quot;</span><span style="color:#a3be8c;">Error: {:?}</span><span>&quot;, err) </span><span style="color:#65737e;">// Ooops, we hit an error, tell the user
</span><span>}
</span></code></pre>
<p>Great, you might think, that's cute.  Well, at least at first.  Real code tends to have a few reads in a row:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">let</span><span> num_chans = </span><span style="color:#96b5b4;">read_u16_le</span><span>(&amp;</span><span style="color:#b48ead;">mut</span><span> f);
</span><span style="color:#b48ead;">let</span><span> samples_per_sec = </span><span style="color:#96b5b4;">read_u32_le</span><span>(&amp;</span><span style="color:#b48ead;">mut</span><span> f);
</span><span style="color:#b48ead;">let</span><span> avg_bytes_per_sec = </span><span style="color:#96b5b4;">read_u32_le</span><span>(&amp;</span><span style="color:#b48ead;">mut</span><span> f);
</span><span style="color:#b48ead;">let</span><span> block_align = </span><span style="color:#96b5b4;">read_u16_le</span><span>(&amp;</span><span style="color:#b48ead;">mut</span><span> f);
</span><span style="color:#b48ead;">let</span><span> bits_per_sample = </span><span style="color:#96b5b4;">read_u16_le</span><span>(&amp;</span><span style="color:#b48ead;">mut</span><span> f);
</span></code></pre>
<p>Since we're reading from a file, any of these reads could hit an error.  Perhaps the hard drive dies, or we prematurely hit the end of the file.  Because of that, each function returns a Result that we later have to pattern match to get the value out.  This means we have to pattern match every result.  Yuck.</p>
<p>If you poke around on the internets, you'll find a sneaky way around this using <code>.unwrap()</code>.  The <code>.unwrap()</code> call does just what it name implies: it unwraps the Result and gives us the value, assuming the result is Ok.  What if it errored with an Err? Well, then the application panics.</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">let</span><span> num_chans = </span><span style="color:#96b5b4;">read_u16_le</span><span>(&amp;</span><span style="color:#b48ead;">mut</span><span> f).</span><span style="color:#96b5b4;">unwrap</span><span>();
</span><span style="color:#b48ead;">let</span><span> samples_per_sec = </span><span style="color:#96b5b4;">read_u32_le</span><span>(&amp;</span><span style="color:#b48ead;">mut</span><span> f).</span><span style="color:#96b5b4;">unwrap</span><span>();
</span><span style="color:#b48ead;">let</span><span> avg_bytes_per_sec = </span><span style="color:#96b5b4;">read_u32_le</span><span>(&amp;</span><span style="color:#b48ead;">mut</span><span> f).</span><span style="color:#96b5b4;">unwrap</span><span>();
</span><span style="color:#b48ead;">let</span><span> block_align = </span><span style="color:#96b5b4;">read_u16_le</span><span>(&amp;</span><span style="color:#b48ead;">mut</span><span> f).</span><span style="color:#96b5b4;">unwrap</span><span>();
</span><span style="color:#b48ead;">let</span><span> bits_per_sample = </span><span style="color:#96b5b4;">read_u16_le</span><span>(&amp;</span><span style="color:#b48ead;">mut</span><span> f).</span><span style="color:#96b5b4;">unwrap</span><span>();
</span></code></pre>
<p>If you felt a cold shiver run down your spine looking at that, good on you :).  Now, let's talk about how we actually fix this code.</p>
<h1 id="do-or-do-not-there-is-a-try">Do or do not. There is a try!</h1>
<p>Looking a bit further in Rust examples, I learned about another way to call functions using the <code>try!</code> macro.  Maybe, I thought, <code>try!</code> would save us.  So I tried it out:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">use </span><span>std::io;
</span><span style="color:#b48ead;">use </span><span>std::fs::File;
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> f = try!(File::open(&quot;</span><span style="color:#a3be8c;">foo.txt</span><span>&quot;));
</span><span>}
</span></code></pre>
<p>...and <strong>BOOM</strong></p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>&lt;std macros&gt;:5:8: 6:42 error: mismatched types:
</span><span> expected `()`,
</span><span>    found `core::result::Result&lt;_, _&gt;`
</span><span>(expected (),
</span><span>    found enum `core::result::Result`) [E0308]
</span><span>&lt;std macros&gt;:5 return $ crate:: result:: Result:: Err (
</span><span>&lt;std macros&gt;:6 $ crate:: convert:: From:: from ( err ) ) } } )
</span><span>read_a_file.rs:5:17: 5:44 note: in this expansion of try! (defined in &lt;std macros&gt;)
</span><span>&lt;std macros&gt;:5:8: 6:42 help: run `rustc --explain E0308` to see a detailed explanation
</span><span>error: aborting due to previous error
</span></code></pre>
<p>Okay, seriously?  I feel like I jumped in the Haskell pool after drinking a C++ template error cocktail.  What <em>is</em> that?</p>
<p>Luckily after asking around, I was finally able to piece together what was going wrong.  The hint lies in these lines:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span> expected `()`,
</span><span>    found `core::result::Result&lt;_, _&gt;`
</span></code></pre>
<p>Ah, some type mismatch is happening.  Our main function doesn't return anything, which is the <code>()</code> in the 'expected' above, but <code>try!</code> only works inside functions that return a <code>Result</code>.  This might be the first time in my life I've ever seen a function in a C-style language that was callable only inside functions of a particular type.</p>
<p>Shouldn't be too hard to fix, just put it in a function that returns Result, right?</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">use </span><span>std::io;
</span><span style="color:#b48ead;">use </span><span>std::fs::File;
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">read_file</span><span>() -&gt; Result&lt;(), io::Error&gt; {
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> f = try!(File::open(&quot;</span><span style="color:#a3be8c;">foo.txt</span><span>&quot;));
</span><span>    Ok(())
</span><span>}
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#96b5b4;">read_file</span><span>();
</span><span>}
</span></code></pre>
<p>Yup, that did it.  Then I promptly closed my editor and walked away.  I mean, this thing just felt <em>alien</em>.  Unnatural.  Gross.</p>
<p>What I didn't realize was that a few weeks later I'd grok the genius in this approach.</p>
<h2 id="genius-1-unlike-try-catch-try-is-precise">Genius #1 - Unlike try/catch, try! is precise</h2>
<p>Let's look at a real-life example from a project I'm working on:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">load_data</span><span>(</span><span style="color:#bf616a;">fname</span><span>: &amp;String) -&gt; Result&lt;Data, io::Error&gt; {
</span><span>  </span><span style="color:#b48ead;">let mut</span><span> f = try!(File::open(fname));
</span><span>  </span><span style="color:#b48ead;">let</span><span> num_pages = try!(f.</span><span style="color:#96b5b4;">read_u8</span><span>()) * </span><span style="color:#d08770;">4</span><span>;
</span><span> 
</span><span>  </span><span style="color:#b48ead;">let mut</span><span> pages : Vec&lt;Vec&lt;</span><span style="color:#b48ead;">u8</span><span>&gt;&gt; = Vec::new();
</span><span>  </span><span style="color:#b48ead;">for </span><span>_ in </span><span style="color:#d08770;">0</span><span>..num_pages {
</span><span>      </span><span style="color:#b48ead;">let mut</span><span> buffer = [</span><span style="color:#d08770;">0</span><span>; </span><span style="color:#d08770;">4096</span><span>];
</span><span>      try!(f.</span><span style="color:#96b5b4;">read</span><span>(&amp;</span><span style="color:#b48ead;">mut</span><span> buffer));
</span><span>      
</span><span>      pages.</span><span style="color:#96b5b4;">push</span><span>(buffer.</span><span style="color:#96b5b4;">iter</span><span>().</span><span style="color:#96b5b4;">cloned</span><span>().</span><span style="color:#96b5b4;">collect</span><span>());
</span><span>  }
</span><span>  </span><span style="color:#65737e;">// ...
</span><span>}
</span></code></pre>
<p>It may take your eyes a minute to adjust to the new syntax, but knowing what we know, we can look at the code above and know exactly which functions might give us errors.  The <code>try!()</code> call even works on calls that are part of an expression, like <code>try!(f.read_u8()) * 4</code>.</p>
<p>Compare this to traditional try/catch blocks and how they tend to get put around whole sections of code when in reality only parts of the code blocks may throw exceptions.  The end result is code that's very clear and doesn't muddy exceptional code and value-based code together.</p>
<h2 id="genius-2-feels-like-exceptions">Genius #2 - Feels like exceptions</h2>
<p>With this little bit of syntax, we get something that is value-based, but still feels like exceptions.</p>
<p>Let's say your task is to write code that will load a variety of audio file formats.  In each audio format loader, you have various subsections that get loaded (eg, a header, a metadata chunk, a chunk of audio data, etc).  It'd be great if you could create specialized functions for each.  If there are any errors, you just want to bubble that back out to the original caller loading the file.  The resulting code may look something like:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">load_header</span><span>(</span><span style="color:#bf616a;">file</span><span>: &amp;</span><span style="color:#b48ead;">mut</span><span> File) -&gt; Result&lt;Header, io::Error&gt; {
</span><span>  Ok(Header { header_block: try!(file.</span><span style="color:#96b5b4;">read_u32</span><span>()) })
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">load_metadata</span><span>(</span><span style="color:#bf616a;">file</span><span>: &amp;</span><span style="color:#b48ead;">mut</span><span> File) -&gt; Result&lt;Metadata, io::Error&gt; {
</span><span>  Ok(Metadata { metadata_block: try!(file.</span><span style="color:#96b5b4;">read_u32</span><span>()) })
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">load_audio</span><span>(</span><span style="color:#bf616a;">file</span><span>: &amp;</span><span style="color:#b48ead;">mut</span><span> File) -&gt; Result&lt;Audio, io::Error&gt; {
</span><span>  </span><span style="color:#b48ead;">let</span><span> header = try!(</span><span style="color:#96b5b4;">load_header</span><span>(file));
</span><span>  </span><span style="color:#b48ead;">let</span><span> metadata = try!(</span><span style="color:#96b5b4;">load_metadata</span><span>(file));
</span><span>  Ok(Audio { header: header, metadata: metadata })
</span><span>}
</span></code></pre>
<p>We can refactor our file loading into helper functions, and we continue to use the same familiar <code>try!</code> pattern.  How does this work?  The trick is that all the Results agree that <code>io::Error</code> is the error case.  If one of my helper functions hits a bad read and has to return an error, that error naturally bubbles all the way out without calling any additional code.</p>
<p>The end result is that we have precise syntax that is transparent about errors at every layer, stays pretty lightweight, and gives us the familiar "bubble out" feel of languages with exceptions.</p>
<h1 id="trade-offs">Trade-offs</h1>
<p>Of course, there are trade-offs.  We end up repeating <code>try!()</code> in places we might have just wrapped in one big try/catch block.  For example, the fix to our earlier use case might look like this:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">let</span><span> num_chans = try!(</span><span style="color:#96b5b4;">read_u16_le</span><span>(&amp;</span><span style="color:#b48ead;">mut</span><span> f));
</span><span style="color:#b48ead;">let</span><span> samples_per_sec = try!(</span><span style="color:#96b5b4;">read_u32_le</span><span>(&amp;</span><span style="color:#b48ead;">mut</span><span> f));
</span><span style="color:#b48ead;">let</span><span> avg_bytes_per_sec = try!(</span><span style="color:#96b5b4;">read_u32_le</span><span>(&amp;</span><span style="color:#b48ead;">mut</span><span> f));
</span><span style="color:#b48ead;">let</span><span> block_align = try!(</span><span style="color:#96b5b4;">read_u16_le</span><span>(&amp;</span><span style="color:#b48ead;">mut</span><span> f));
</span><span style="color:#b48ead;">let</span><span> bits_per_sample = try!(</span><span style="color:#96b5b4;">read_u16_le</span><span>(&amp;</span><span style="color:#b48ead;">mut</span><span> f));
</span></code></pre>
<p>Personally, I'm happy making the trade-off for the added precision.</p>
<p>We also saw another trade-off earlier.  If you use <code>try!()</code> in a function that doesn't return a Result, you get an incomprehensible error message.  But once you know what's going on, you can use it with confidence.</p>

  </div>

  <hr class="footer-rule" />

  
    <div class="footer-about">
      <p>A simple dev-blog theme created by Bennett. You can follow him on <a href="https://github.com/bennetthardwick">Github</a> (if you like).</p>

    </div>
  

  <div class="related-container">

    

    

  </div>


    </main>
  </body>
</html>
